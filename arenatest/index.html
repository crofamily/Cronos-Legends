<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cronos Legends - Battle Arena</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --guardian-color: #00d4ff;
            --chaos-color: #ff0055;
            --trinari-color: #00ff88;
            --bg-dark: #0a0a0f;
            --gold: #ffd700;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(-45deg, #0a0a0f, #1a0a2e, #16213e, #0f3460);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            color: #fff;
            overflow: hidden;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .stars-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20px 30px, #eee, transparent),
                radial-gradient(2px 2px at 60px 70px, #fff, transparent),
                radial-gradient(1px 1px at 50px 50px, #ddd, transparent);
            background-size: 200px 200px;
            opacity: 0.3;
            animation: twinkle 20s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.5; }
        }

        /* Main Menu */
        .main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .main-menu h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 5em;
            margin-bottom: 20px;
            background: linear-gradient(45deg, var(--guardian-color), var(--chaos-color), var(--trinari-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 10px;
            animation: glow 3s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(0, 212, 255, 0.6)); }
            50% { filter: drop-shadow(0 0 40px rgba(255, 0, 85, 0.8)); }
        }

        .menu-subtitle {
            font-size: 1.5em;
            color: #888;
            letter-spacing: 4px;
            margin-bottom: 60px;
        }

        .mode-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            max-width: 1400px;
        }

        .mode-card {
            background: rgba(20, 20, 30, 0.9);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 40px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            min-width: 350px;
        }

        .mode-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(0, 212, 255, 0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mode-card:hover::before {
            opacity: 1;
        }

        .mode-card:hover {
            transform: translateY(-15px);
            border-color: var(--guardian-color);
            box-shadow: 0 20px 60px rgba(0, 212, 255, 0.5);
        }

        .mode-card.practice:hover {
            border-color: var(--trinari-color);
            box-shadow: 0 20px 60px rgba(0, 255, 136, 0.5);
        }

        .mode-card.team:hover {
            border-color: var(--chaos-color);
            box-shadow: 0 20px 60px rgba(255, 0, 85, 0.5);
        }

        .mode-icon {
            font-size: 4em;
            margin-bottom: 20px;
            text-align: center;
        }

        .mode-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2em;
            font-weight: 700;
            text-align: center;
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .mode-description {
            text-align: center;
            color: #aaa;
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .mode-stats {
            display: flex;
            justify-content: space-around;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mode-stat {
            text-align: center;
        }

        .mode-stat-label {
            font-size: 0.9em;
            color: #666;
            text-transform: uppercase;
        }

        .mode-stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3em;
            font-weight: 700;
            color: var(--guardian-color);
            margin-top: 5px;
        }

        /* Queue Screen */
        .queue-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .queue-screen h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 3em;
            margin-bottom: 30px;
            color: var(--guardian-color);
        }

        .queue-animation {
            width: 150px;
            height: 150px;
            border: 5px solid rgba(0, 212, 255, 0.2);
            border-top-color: var(--guardian-color);
            border-radius: 50%;
            animation: spin 1.5s linear infinite;
            margin-bottom: 30px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .queue-status {
            font-size: 1.5em;
            color: #aaa;
            margin-bottom: 10px;
        }

        .queue-timer {
            font-family: 'Orbitron', sans-serif;
            font-size: 2em;
            color: var(--trinari-color);
            margin-bottom: 40px;
        }

        .cancel-queue-btn {
            font-family: 'Orbitron', sans-serif;
            padding: 15px 40px;
            background: rgba(255, 0, 85, 0.8);
            border: 2px solid var(--chaos-color);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .cancel-queue-btn:hover {
            background: var(--chaos-color);
            transform: scale(1.05);
        }

        #gameCanvas {
            display: none;
            width: 100vw;
            height: 100vh;
        }

        /* Skill Selection Screen */
        .skill-selection-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        .skill-selection-screen h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 3em;
            margin-bottom: 20px;
            background: linear-gradient(45deg, var(--guardian-color), var(--chaos-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .skill-selection-screen p {
            font-size: 1.3em;
            margin-bottom: 40px;
            color: #888;
        }

        .skills-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            max-width: 1200px;
            margin-bottom: 30px;
        }

        .skill-card {
            background: rgba(20, 20, 40, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .skill-card:hover {
            transform: translateY(-10px);
            border-color: var(--guardian-color);
            box-shadow: 0 10px 40px rgba(0, 212, 255, 0.5);
        }

        .skill-card.selected {
            border-color: var(--trinari-color);
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 10px 40px rgba(0, 255, 136, 0.5);
        }

        .skill-card.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .skill-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .skill-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2em;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .skill-description {
            font-size: 0.9em;
            color: #aaa;
        }

        .start-battle-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            padding: 20px 60px;
            background: linear-gradient(135deg, var(--guardian-color), var(--chaos-color));
            border: none;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .start-battle-btn:hover:not(:disabled) {
            transform: scale(1.1);
            box-shadow: 0 10px 50px rgba(0, 212, 255, 0.8);
        }

        .start-battle-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Countdown Overlay */
        .countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1500;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .countdown-number {
            font-family: 'Orbitron', sans-serif;
            font-size: 15em;
            font-weight: 900;
            background: linear-gradient(45deg, var(--guardian-color), var(--chaos-color), var(--trinari-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: pulse 1s ease;
        }

        @keyframes pulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Game UI */
        .game-ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .player-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid var(--guardian-color);
            pointer-events: all;
        }

        .health-bar, .stamina-bar {
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 10px;
            position: relative;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0055, #ff5555);
            transition: width 0.3s ease;
        }

        .stamina-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--trinari-color), #00aa66);
            transition: width 0.3s ease;
        }

        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
        }

        .tower-hud {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid var(--chaos-color);
        }

        .abilities-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: all;
        }

        .ability-btn {
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--guardian-color);
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8em;
            color: white;
            transition: all 0.2s ease;
            position: relative;
        }

        .ability-btn:hover:not(.on-cooldown) {
            transform: scale(1.1);
            box-shadow: 0 0 30px var(--guardian-color);
        }

        .ability-btn.on-cooldown {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .ability-icon {
            font-size: 2em;
        }

        .ability-key {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255, 255, 255, 0.2);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8em;
        }

        .controls-hint {
            position: absolute;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.1em;
        }

        .minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--guardian-color);
            border-radius: 10px;
        }

        .victory-screen, .defeat-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .victory-screen h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 6em;
            color: var(--gold);
            margin-bottom: 30px;
            text-shadow: 0 0 50px var(--gold);
        }

        .defeat-screen h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 6em;
            color: var(--chaos-color);
            margin-bottom: 30px;
            text-shadow: 0 0 50px var(--chaos-color);
        }

        .return-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3em;
            padding: 15px 50px;
            background: linear-gradient(135deg, var(--guardian-color), var(--chaos-color));
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .return-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 40px rgba(0, 212, 255, 0.8);
        }
    </style>
</head>
<body>
    <div class="stars-bg"></div>

    <!-- Main Menu -->
    <div class="main-menu" id="mainMenu">
        <h1>‚öîÔ∏è Battle Arena ‚öîÔ∏è</h1>
        <div class="menu-subtitle">Cronos Legends</div>
        
        <div class="mode-cards">
            <div class="mode-card practice" onclick="selectMode('practice')">
                <div class="mode-icon">üéØ</div>
                <div class="mode-title" style="color: var(--trinari-color);">Practice Mode</div>
                <div class="mode-description">
                    Train against AI to master your skills. No queue, instant action!
                </div>
                <div class="mode-stats">
                    <div class="mode-stat">
                        <div class="mode-stat-label">Queue</div>
                        <div class="mode-stat-value" style="color: var(--trinari-color);">None</div>
                    </div>
                    <div class="mode-stat">
                        <div class="mode-stat-label">Players</div>
                        <div class="mode-stat-value" style="color: var(--trinari-color);">1v1</div>
                    </div>
                </div>
            </div>

            <div class="mode-card" onclick="selectMode('1v1')">
                <div class="mode-icon">‚öîÔ∏è</div>
                <div class="mode-title" style="color: var(--guardian-color);">1v1 Duel</div>
                <div class="mode-description">
                    Face a real opponent in intense one-on-one combat. Prove your superiority!
                </div>
                <div class="mode-stats">
                    <div class="mode-stat">
                        <div class="mode-stat-label">Queue</div>
                        <div class="mode-stat-value">Required</div>
                    </div>
                    <div class="mode-stat">
                        <div class="mode-stat-label">Players</div>
                        <div class="mode-stat-value">2</div>
                    </div>
                </div>
            </div>

            <div class="mode-card team" onclick="selectMode('2v2')">
                <div class="mode-icon">üî•</div>
                <div class="mode-title" style="color: var(--chaos-color);">2v2 Team Battle</div>
                <div class="mode-description">
                    Team up with an ally to dominate the battlefield. Coordination is key!
                </div>
                <div class="mode-stats">
                    <div class="mode-stat">
                        <div class="mode-stat-label">Queue</div>
                        <div class="mode-stat-value" style="color: var(--chaos-color);">Required</div>
                    </div>
                    <div class="mode-stat">
                        <div class="mode-stat-label">Players</div>
                        <div class="mode-stat-value" style="color: var(--chaos-color);">4</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Queue Screen -->
    <div class="queue-screen" id="queueScreen">
        <h1 id="queueModeTitle">Searching for Match...</h1>
        <div class="queue-animation"></div>
        <div class="queue-status" id="queueStatus">Looking for opponents...</div>
        <div class="queue-timer" id="queueTimer">0:00</div>
        <button class="cancel-queue-btn" onclick="cancelQueue()">Cancel Queue</button>
    </div>
    <!-- Skill Selection Screen -->
    <div class="skill-selection-screen" id="skillSelection">
        <h1>‚öîÔ∏è CHOOSE YOUR ABILITIES ‚öîÔ∏è</h1>
        <p>Select 3 abilities for battle (<span id="selectedCount">0</span>/3)</p>
        
        <div class="skills-grid" id="skillsGrid"></div>
        
        <button class="start-battle-btn" id="startBattleBtn" disabled>START BATTLE</button>
    </div>

    <!-- Countdown Overlay -->
    <div class="countdown-overlay" id="countdownOverlay" style="display: none;">
        <div class="countdown-number" id="countdownNumber">5</div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Game UI -->
    <div class="game-ui" id="gameUI" style="display: none;">
        <!-- Player HUD -->
        <div class="player-hud">
            <div>
                <div class="health-bar">
                    <div class="health-fill" id="playerHealthFill" style="width: 100%;"></div>
                    <div class="bar-text">HP: <span id="playerHP">100</span> / 100</div>
                </div>
                <div class="stamina-bar">
                    <div class="stamina-fill" id="playerStaminaFill" style="width: 100%;"></div>
                    <div class="bar-text">Stamina: <span id="playerStamina">100</span></div>
                </div>
            </div>
        </div>

        <!-- Tower HUD -->
        <div class="tower-hud">
            <div style="margin-bottom: 10px;">
                <strong>Your Tower</strong>
                <div class="health-bar">
                    <div class="health-fill" id="playerTowerFill" style="width: 100%;"></div>
                    <div class="bar-text"><span id="playerTowerHP">500</span> / 500</div>
                </div>
            </div>
            <div>
                <strong>Enemy Tower</strong>
                <div class="health-bar" style="border-color: var(--chaos-color);">
                    <div class="health-fill" id="enemyTowerFill" style="width: 100%;"></div>
                    <div class="bar-text"><span id="enemyTowerHP">500</span> / 500</div>
                </div>
            </div>
        </div>

        <!-- Abilities Bar -->
        <div class="abilities-bar" id="abilitiesBar"></div>

        <!-- Controls Hint -->
        <div class="controls-hint">
            WASD: Move | Mouse: Aim | Left Click: Shoot | Q/E/R: Abilities
        </div>
    </div>

    <!-- Victory Screen -->
    <div class="victory-screen" id="victoryScreen" style="display: none;">
        <h1>üèÜ VICTORY! üèÜ</h1>
        <p style="font-size: 1.5em; margin-bottom: 30px;">You have defeated your enemy!</p>
        <button class="return-btn" onclick="location.reload()">Return to Menu</button>
    </div>

    <!-- Defeat Screen -->
    <div class="defeat-screen" id="defeatScreen" style="display: none;">
        <h1>üíÄ DEFEAT üíÄ</h1>
        <p style="font-size: 1.5em; margin-bottom: 30px;">Your forces have fallen...</p>
        <button class="return-btn" onclick="location.reload()">Return to Menu</button>
    </div>

    <script>
        // Game mode
        let currentGameMode = null;
        let inQueue = false;
        let queueStartTime = 0;

        // Mode Selection
        // Queue System
        function enterQueue(mode) {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('queueScreen').style.display = 'flex';
            
            const modeNames = {
                '1v1': '1v1 Duel',
                '2v2': '2v2 Team Battle'
            };
            
            document.getElementById('queueModeTitle').textContent = `Searching for ${modeNames[mode]}...`;
            
            inQueue = true;
            queueStartTime = Date.now();
            updateQueueTimer();
            
            // Simulate finding a match (in real game, this would be backend matchmaking)
            const matchTime = 3000 + Math.random() * 5000; // 3-8 seconds
            setTimeout(() => {
                if (inQueue) {
                    matchFound();
                }
            }, matchTime);
        }

        function matchFound() {
            document.getElementById('queueStatus').textContent = 'Match Found!';
            document.getElementById('queueStatus').style.color = '#00ff88';
            
            setTimeout(() => {
                document.getElementById('queueScreen').style.display = 'none';
                initSkillSelection();
                document.getElementById('skillSelection').style.display = 'flex';
                inQueue = false;
            }, 1000);
        }

        // Make selectMode globally accessible
        window.selectMode = function(mode) {
            currentGameMode = mode;
            selectedSkills = []; // Reset skills
            
            if (mode === 'practice') {
                // Go directly to skill selection for practice
                document.getElementById('mainMenu').style.display = 'none';
                initSkillSelection();
                document.getElementById('skillSelection').style.display = 'flex';
            } else {
                // Enter queue for competitive modes
                enterQueue(mode);
            }
        };

        function updateQueueTimer() {
            if (!inQueue) return;
            
            const elapsed = Math.floor((Date.now() - queueStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('queueTimer').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            setTimeout(updateQueueTimer, 1000);
        }

        window.cancelQueue = function() {
            inQueue = false;
            document.getElementById('queueScreen').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
        };

        // Available Skills
        const AVAILABLE_SKILLS = [
            {
                id: 'sprint',
                name: 'Sprint',
                icon: '‚ö°',
                description: '3x speed boost for 3 seconds',
                cooldown: 10000,
                duration: 3000,
                execute: (player) => {
                    player.speed *= 3;
                    setTimeout(() => player.speed /= 3, 3000);
                }
            },
            {
                id: 'heal',
                name: 'Self Heal',
                icon: 'üíö',
                description: 'Restore 30 HP instantly',
                cooldown: 15000,
                execute: (player) => {
                    player.health = Math.min(100, player.health + 30);
                }
            },
            {
                id: 'teleport',
                name: 'Teleport',
                icon: 'üåÄ',
                description: 'Teleport forward 15 units',
                cooldown: 12000,
                execute: (player) => {
                    const forward = new THREE.Vector3(0, 0, -15);
                    forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.mesh.rotation.y);
                    player.mesh.position.add(forward);
                }
            },
            {
                id: 'shield',
                name: 'Force Shield',
                icon: 'üõ°Ô∏è',
                description: 'Block all damage for 2 seconds',
                cooldown: 20000,
                duration: 2000,
                execute: (player) => {
                    player.shielded = true;
                    setTimeout(() => player.shielded = false, 2000);
                }
            },
            {
                id: 'rapidfire',
                name: 'Rapid Fire',
                icon: 'üî•',
                description: 'Shoot 5 fast projectiles',
                cooldown: 8000,
                execute: (player) => {
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => shootProjectile(player), i * 150);
                    }
                }
            },
            {
                id: 'smoke',
                name: 'Smoke Bomb',
                icon: 'üí®',
                description: 'Become invisible for 3 seconds',
                cooldown: 25000,
                duration: 3000,
                execute: (player) => {
                    player.invisible = true;
                    player.mesh.visible = false;
                    setTimeout(() => {
                        player.invisible = false;
                        player.mesh.visible = true;
                    }, 3000);
                }
            },
            {
                id: 'powershot',
                name: 'Power Shot',
                icon: 'üí•',
                description: 'Massive damage projectile',
                cooldown: 15000,
                execute: (player) => {
                    shootPowerProjectile(player);
                }
            },
            {
                id: 'regen',
                name: 'Regeneration',
                icon: '‚ú®',
                description: 'Heal 5 HP/sec for 6 seconds',
                cooldown: 20000,
                duration: 6000,
                execute: (player) => {
                    let ticks = 0;
                    const regenInterval = setInterval(() => {
                        player.health = Math.min(100, player.health + 5);
                        ticks++;
                        if (ticks >= 6) clearInterval(regenInterval);
                    }, 1000);
                }
            },
            {
                id: 'freeze',
                name: 'Freeze Zone',
                icon: '‚ùÑÔ∏è',
                description: 'Slow nearby enemies by 50%',
                cooldown: 18000,
                duration: 4000,
                execute: (player) => {
                    // Implementation would affect nearby enemies
                }
            },
            {
                id: 'dash',
                name: 'Combat Dash',
                icon: 'üí®',
                description: 'Quick dodge in any direction',
                cooldown: 5000,
                execute: (player) => {
                    const dashDir = new THREE.Vector3(player.velocity.x, 0, player.velocity.z);
                    if (dashDir.length() > 0) {
                        dashDir.normalize().multiplyScalar(10);
                        player.mesh.position.add(dashDir);
                    }
                }
            }
        ];

        // Selected Skills
        let selectedSkills = [];

        // Initialize Skill Selection
        function initSkillSelection() {
            const grid = document.getElementById('skillsGrid');
            grid.innerHTML = ''; // Clear existing skills
            const btn = document.getElementById('startBattleBtn');
            btn.disabled = true;
            document.getElementById('selectedCount').textContent = '0';
            
            AVAILABLE_SKILLS.forEach(skill => {
                const card = document.createElement('div');
                card.className = 'skill-card';
                card.innerHTML = `
                    <div class="skill-icon">${skill.icon}</div>
                    <div class="skill-name">${skill.name}</div>
                    <div class="skill-description">${skill.description}</div>
                `;
                
                card.onclick = () => {
                    if (card.classList.contains('selected')) {
                        card.classList.remove('selected');
                        selectedSkills = selectedSkills.filter(s => s.id !== skill.id);
                    } else if (selectedSkills.length < 3) {
                        card.classList.add('selected');
                        selectedSkills.push(skill);
                    }
                    
                    document.getElementById('selectedCount').textContent = selectedSkills.length;
                    btn.disabled = selectedSkills.length !== 3;
                    
                    // Disable unselected if 3 selected
                    if (selectedSkills.length === 3) {
                        document.querySelectorAll('.skill-card:not(.selected)').forEach(c => {
                            c.classList.add('disabled');
                        });
                    } else {
                        document.querySelectorAll('.skill-card').forEach(c => {
                            c.classList.remove('disabled');
                        });
                    }
                };
                
                grid.appendChild(card);
            });
            
            btn.onclick = startBattle;
        }

        // Start Battle
        function startBattle() {
            document.getElementById('skillSelection').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            
            initGame();
            showCountdown();
        }

        // Countdown
        function showCountdown() {
            const overlay = document.getElementById('countdownOverlay');
            const number = document.getElementById('countdownNumber');
            overlay.style.display = 'flex';
            
            let count = 5;
            number.textContent = count;
            
            const countInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    number.textContent = count;
                    number.style.animation = 'none';
                    setTimeout(() => number.style.animation = 'pulse 1s ease', 10);
                } else {
                    clearInterval(countInterval);
                    overlay.style.display = 'none';
                    document.getElementById('gameUI').style.display = 'block';
                    startGameLoop();
                }
            }, 1000);
        }

        // Game Variables
        let scene, camera, renderer;
        let player, enemy;
        let playerTower, enemyTower;
        let projectiles = [];
        let obstacles = []; // Trees, rocks that can be destroyed
        let pickups = []; // Health and stamina pickups
        let keys = {};
        let mousePos = { x: 0, y: 0 };
        let gameRunning = false;
        let cameraOffset = new THREE.Vector3(0, 30, 20);
        let lastPickupSpawn = 0;
        let pickupSpawnInterval = 5000; // 5 seconds
        let nextPickupType = 'health'; // Alternates between health and stamina

        // Player Stats
        const createPlayer = (x, z, color, isPlayer = true) => {
            const group = new THREE.Group();
            
            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 16);
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            group.add(body);
            
            // Direction indicator
            const coneGeo = new THREE.ConeGeometry(0.4, 1, 8);
            const cone = new THREE.Mesh(coneGeo, bodyMat);
            cone.rotation.x = Math.PI / 2;
            cone.position.z = 0.8;
            cone.castShadow = true;
            group.add(cone);
            
            group.position.set(x, 0.5, z);
            scene.add(group);
            
            return {
                mesh: group,
                health: 100,
                maxHealth: 100,
                stamina: 100,
                maxStamina: 100,
                speed: 0.15,
                velocity: { x: 0, z: 0 },
                shielded: false,
                invisible: false,
                abilities: selectedSkills.map(skill => ({
                    ...skill,
                    ready: true,
                    lastUsed: 0
                })),
                isPlayer: isPlayer
            };
        };

        // Create Tower
        const createTower = (x, z, color) => {
            const group = new THREE.Group();
            
            // Tower base
            const baseGeo = new THREE.CylinderGeometry(2, 3, 6, 8);
            const baseMat = new THREE.MeshStandardMaterial({ 
                color: color,
                metalness: 0.7,
                roughness: 0.3
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);
            
            // Tower top
            const topGeo = new THREE.ConeGeometry(2.5, 3, 8);
            const top = new THREE.Mesh(topGeo, baseMat);
            top.position.y = 4.5;
            top.castShadow = true;
            group.add(top);
            
            group.position.set(x, 3, z);
            
            // Add collision
            group.userData = {
                isObstacle: true,
                isTower: true,
                collisionRadius: 3
            };
            
            scene.add(group);
            
            return {
                mesh: group,
                health: 500,
                maxHealth: 500
            };
        };

        // Create Tree
        const createTree = (x, z) => {
            const group = new THREE.Group();
            
            // Trunk
            const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1.5;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            group.add(trunk);
            
            // Leaves
            const leavesGeo = new THREE.SphereGeometry(1.5, 8, 8);
            const leavesMat = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                roughness: 0.8
            });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 3.5;
            leaves.castShadow = true;
            leaves.receiveShadow = true;
            group.add(leaves);
            
            group.position.set(x, 0, z);
            
            // Add health and collision
            group.userData = {
                isObstacle: true,
                health: 3,
                maxHealth: 3,
                type: 'tree'
            };
            
            scene.add(group);
            obstacles.push(group);
        };

        // Create Rock
        const createRock = (x, z, scale = 1) => {
            const rockGeo = new THREE.DodecahedronGeometry(scale, 0);
            const rockMat = new THREE.MeshStandardMaterial({ 
                color: 0x808080,
                roughness: 0.9,
                metalness: 0.1
            });
            const rock = new THREE.Mesh(rockGeo, rockMat);
            rock.position.set(x, scale * 0.5, z);
            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            rock.castShadow = true;
            rock.receiveShadow = true;
            
            // Add health and collision
            rock.userData = {
                isObstacle: true,
                health: 5,
                maxHealth: 5,
                type: 'rock',
                scale: scale
            };
            
            scene.add(rock);
            obstacles.push(rock);
        };

        // Create Bush
        const createBush = (x, z) => {
            const group = new THREE.Group();
            
            // Multiple small spheres for bush appearance
            for (let i = 0; i < 3; i++) {
                const bushGeo = new THREE.SphereGeometry(0.6 + Math.random() * 0.3, 8, 8);
                const bushMat = new THREE.MeshStandardMaterial({ 
                    color: 0x2F4F2F,
                    roughness: 1
                });
                const bushPart = new THREE.Mesh(bushGeo, bushMat);
                bushPart.position.set(
                    (Math.random() - 0.5) * 0.8,
                    0.4,
                    (Math.random() - 0.5) * 0.8
                );
                bushPart.castShadow = true;
                bushPart.receiveShadow = true;
                group.add(bushPart);
            }
            
            group.position.set(x, 0, z);
            scene.add(group);
        };

        // Create Stone Path
        const createStone = (x, z) => {
            const stoneGeo = new THREE.CylinderGeometry(0.8, 0.9, 0.3, 8);
            const stoneMat = new THREE.MeshStandardMaterial({ 
                color: 0xA9A9A9,
                roughness: 0.8,
                metalness: 0.2
            });
            const stone = new THREE.Mesh(stoneGeo, stoneMat);
            stone.position.set(x, 0.15, z);
            stone.rotation.y = Math.random() * Math.PI;
            stone.castShadow = true;
            stone.receiveShadow = true;
            scene.add(stone);
        };

        // Create Flower Patch
        const createFlowerPatch = (x, z) => {
            const group = new THREE.Group();
            
            // Base grass
            const baseGeo = new THREE.CircleGeometry(0.5, 8);
            const baseMat = new THREE.MeshStandardMaterial({ 
                color: 0x90EE90,
                side: THREE.DoubleSide
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.rotation.x = -Math.PI / 2;
            base.receiveShadow = true;
            group.add(base);
            
            // Flowers
            for (let i = 0; i < 5; i++) {
                const flowerGeo = new THREE.SphereGeometry(0.1, 6, 6);
                const colors = [0xFF69B4, 0xFFFF00, 0xFF4500, 0x9370DB];
                const flowerMat = new THREE.MeshStandardMaterial({ 
                    color: colors[Math.floor(Math.random() * colors.length)],
                    emissive: colors[Math.floor(Math.random() * colors.length)],
                    emissiveIntensity: 0.3
                });
                const flower = new THREE.Mesh(flowerGeo, flowerMat);
                flower.position.set(
                    (Math.random() - 0.5) * 0.6,
                    0.1,
                    (Math.random() - 0.5) * 0.6
                );
                group.add(flower);
            }
            
            group.position.set(x, 0.01, z);
            scene.add(group);
        };

        // Create Mushroom
        const createMushroom = (x, z) => {
            const group = new THREE.Group();
            
            // Stem
            const stemGeo = new THREE.CylinderGeometry(0.15, 0.2, 0.8, 8);
            const stemMat = new THREE.MeshStandardMaterial({ color: 0xFFFACD });
            const stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.y = 0.4;
            stem.castShadow = true;
            group.add(stem);
            
            // Cap
            const capGeo = new THREE.SphereGeometry(0.5, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const capMat = new THREE.MeshStandardMaterial({ 
                color: 0xFF6347,
                emissive: 0xFF6347,
                emissiveIntensity: 0.2
            });
            const cap = new THREE.Mesh(capGeo, capMat);
            cap.position.y = 0.8;
            cap.castShadow = true;
            group.add(cap);
            
            // White spots on cap
            for (let i = 0; i < 3; i++) {
                const spotGeo = new THREE.SphereGeometry(0.1, 6, 6);
                const spotMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const spot = new THREE.Mesh(spotGeo, spotMat);
                spot.position.set(
                    (Math.random() - 0.5) * 0.4,
                    0.9,
                    (Math.random() - 0.5) * 0.4
                );
                group.add(spot);
            }
            
            group.position.set(x, 0, z);
            scene.add(group);
        };

        // Create Health Pickup
        const createHealthPickup = (x, z) => {
            const group = new THREE.Group();
            
            // Cross shape (health symbol)
            const crossMat = new THREE.MeshStandardMaterial({ 
                color: 0xff0055,
                emissive: 0xff0055,
                emissiveIntensity: 0.8
            });
            
            const verticalGeo = new THREE.BoxGeometry(0.3, 1, 0.3);
            const vertical = new THREE.Mesh(verticalGeo, crossMat);
            vertical.position.y = 0.5;
            group.add(vertical);
            
            const horizontalGeo = new THREE.BoxGeometry(1, 0.3, 0.3);
            const horizontal = new THREE.Mesh(horizontalGeo, crossMat);
            horizontal.position.y = 0.5;
            group.add(horizontal);
            
            group.position.set(x, 0, z);
            group.userData = {
                type: 'health',
                amount: 30,
                pickupRadius: 2,
                spawnTime: Date.now(),
                lifetime: 20000 // 20 seconds
            };
            
            scene.add(group);
            pickups.push(group);
            
            // Rotate animation
            const rotatePickup = () => {
                if (group.parent) {
                    group.rotation.y += 0.05;
                    requestAnimationFrame(rotatePickup);
                }
            };
            rotatePickup();
        };

        // Create Stamina Pickup
        const createStaminaPickup = (x, z) => {
            const group = new THREE.Group();
            
            // Lightning bolt shape (stamina symbol)
            const boltMat = new THREE.MeshStandardMaterial({ 
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 0.8
            });
            
            const boltGeo = new THREE.ConeGeometry(0.4, 1.2, 4);
            const bolt = new THREE.Mesh(boltGeo, boltMat);
            bolt.position.y = 0.6;
            bolt.rotation.z = Math.PI;
            group.add(bolt);
            
            group.position.set(x, 0, z);
            group.userData = {
                type: 'stamina',
                amount: 40,
                pickupRadius: 2,
                spawnTime: Date.now(),
                lifetime: 20000 // 20 seconds
            };
            
            scene.add(group);
            pickups.push(group);
            
            // Float animation
            let floatOffset = 0;
            const floatPickup = () => {
                if (group.parent) {
                    floatOffset += 0.05;
                    group.position.y = Math.sin(floatOffset) * 0.3;
                    group.rotation.y += 0.05;
                    requestAnimationFrame(floatPickup);
                }
            };
            floatPickup();
        };

        // Spawn Random Pickup
        const spawnRandomPickup = () => {
            const x = (Math.random() - 0.5) * 160; // Avoid edges
            const z = (Math.random() - 0.5) * 70;
            
            if (nextPickupType === 'health') {
                createHealthPickup(x, z);
                nextPickupType = 'stamina';
            } else {
                createStaminaPickup(x, z);
                nextPickupType = 'health';
            }
        };

        // Initialize Game
        function initGame() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 50, 150);
            
            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 20);
            
            // Renderer
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            scene.add(sunLight);
            
            // Ground (grass with texture variation)
            const groundGeo = new THREE.PlaneGeometry(200, 100);
            
            // Create a canvas for grass texture
            const grassCanvas = document.createElement('canvas');
            grassCanvas.width = 512;
            grassCanvas.height = 256;
            const ctx = grassCanvas.getContext('2d');
            
            // Base grass color
            ctx.fillStyle = '#7CFC00';
            ctx.fillRect(0, 0, 512, 256);
            
            // Add grass texture variation
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 256;
                const brightness = Math.random() * 40 - 20;
                ctx.fillStyle = `rgb(${124 + brightness}, ${252 + brightness}, ${0 + brightness})`;
                ctx.fillRect(x, y, 2, 2);
            }
            
            const grassTexture = new THREE.CanvasTexture(grassCanvas);
            grassTexture.wrapS = THREE.RepeatWrapping;
            grassTexture.wrapT = THREE.RepeatWrapping;
            grassTexture.repeat.set(10, 5);
            
            const groundMat = new THREE.MeshStandardMaterial({ 
                map: grassTexture,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Dirt path down the middle
            const pathGeo = new THREE.PlaneGeometry(10, 100);
            const pathMat = new THREE.MeshStandardMaterial({ 
                color: 0x8B7355,
                roughness: 1
            });
            const path = new THREE.Mesh(pathGeo, pathMat);
            path.rotation.x = -Math.PI / 2;
            path.position.y = 0.02;
            path.receiveShadow = true;
            scene.add(path);
            
            // Players
            player = createPlayer(-80, 0, 0x00d4ff, true);
            enemy = createPlayer(80, 0, 0xff0055, false);
            
            // Towers
            playerTower = createTower(-90, 0, 0x00d4ff);
            enemyTower = createTower(90, 0, 0xff0055);
            
            // Populate the map with diverse objects
            // Trees
            for (let i = 0; i < 25; i++) {
                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 80;
                if (Math.abs(z) > 15 || Math.abs(x) < 70) {
                    createTree(x, z);
                }
            }
            
            // Rocks (various sizes)
            for (let i = 0; i < 40; i++) {
                const x = (Math.random() - 0.5) * 190;
                const z = (Math.random() - 0.5) * 90;
                const scale = 0.5 + Math.random() * 1.5;
                if (Math.abs(z) > 12 || Math.abs(x) < 75) {
                    createRock(x, z, scale);
                }
            }
            
            // Bushes
            for (let i = 0; i < 30; i++) {
                const x = (Math.random() - 0.5) * 185;
                const z = (Math.random() - 0.5) * 85;
                if (Math.abs(z) > 13 || Math.abs(x) < 72) {
                    createBush(x, z);
                }
            }
            
            // Stones along the path
            for (let i = 0; i < 20; i++) {
                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 8 + 6; // Along edges of path
                createStone(x, z);
            }
            
            // Flower patches
            for (let i = 0; i < 15; i++) {
                const x = (Math.random() - 0.5) * 190;
                const z = (Math.random() - 0.5) * 90;
                if (Math.abs(z) > 20 || Math.abs(x) < 65) {
                    createFlowerPatch(x, z);
                }
            }
            
            // Mushrooms
            for (let i = 0; i < 12; i++) {
                const x = (Math.random() - 0.5) * 185;
                const z = (Math.random() - 0.5) * 85;
                if (Math.abs(z) > 18 || Math.abs(x) < 68) {
                    createMushroom(x, z);
                }
            }
            
            // Create ability buttons
            createAbilityUI();
            
            // Controls
            setupControls();
        }

        // Create Ability UI
        function createAbilityUI() {
            const bar = document.getElementById('abilitiesBar');
            const keys = ['Q', 'E', 'R'];
            
            selectedSkills.forEach((skill, index) => {
                const btn = document.createElement('div');
                btn.className = 'ability-btn';
                btn.id = `ability-${skill.id}`;
                btn.innerHTML = `
                    <div class="ability-key">${keys[index]}</div>
                    <div class="ability-icon">${skill.icon}</div>
                    <div style="font-size: 0.7em;">${skill.name}</div>
                `;
                btn.onclick = () => useAbility(index);
                bar.appendChild(btn);
            });
        }

        // Use Ability
        function useAbility(index) {
            const ability = player.abilities[index];
            if (!ability.ready || !gameRunning) return;
            
            if (player.stamina < 20) return;
            
            player.stamina = Math.max(0, player.stamina - 20);
            ability.ready = false;
            ability.lastUsed = Date.now();
            
            const btn = document.getElementById(`ability-${ability.id}`);
            btn.classList.add('on-cooldown');
            
            ability.execute(player);
            
            setTimeout(() => {
                ability.ready = true;
                btn.classList.remove('on-cooldown');
            }, ability.cooldown);
        }

        // Setup Controls
        function setupControls() {
            window.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;
                if (e.key === 'q') useAbility(0);
                if (e.key === 'e') useAbility(1);
                if (e.key === 'r') useAbility(2);
            });
            
            window.addEventListener('keyup', e => {
                keys[e.key.toLowerCase()] = false;
            });
            
            window.addEventListener('mousemove', e => {
                mousePos.x = (e.clientX / window.innerWidth) * 2 - 1;
                mousePos.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            
            window.addEventListener('mousedown', () => {
                if (gameRunning) shootProjectile(player);
            });
        }

        // Shoot Projectile
        function shootProjectile(shooter) {
            if (shooter.stamina < 5) return;
            shooter.stamina = Math.max(0, shooter.stamina - 5);
            
            const projGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const projMat = new THREE.MeshStandardMaterial({ 
                color: shooter.isPlayer ? 0x00d4ff : 0xff0055,
                emissive: shooter.isPlayer ? 0x00d4ff : 0xff0055,
                emissiveIntensity: 1
            });
            const proj = new THREE.Mesh(projGeo, projMat);
            proj.position.copy(shooter.mesh.position);
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mousePos, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            
            const dir = new THREE.Vector3().subVectors(target, shooter.mesh.position).normalize();
            
            proj.userData = {
                velocity: dir.multiplyScalar(0.5),
                damage: 15,
                owner: shooter,
                lifetime: 200
            };
            
            scene.add(proj);
            projectiles.push(proj);
        }

        function shootPowerProjectile(shooter) {
            const projGeo = new THREE.SphereGeometry(0.6, 16, 16);
            const projMat = new THREE.MeshStandardMaterial({ 
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 1
            });
            const proj = new THREE.Mesh(projGeo, projMat);
            proj.position.copy(shooter.mesh.position);
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mousePos, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            
            const dir = new THREE.Vector3().subVectors(target, shooter.mesh.position).normalize();
            
            proj.userData = {
                velocity: dir.multiplyScalar(0.4),
                damage: 50,
                owner: shooter,
                lifetime: 200
            };
            
            scene.add(proj);
            projectiles.push(proj);
        }

        // Game Loop
        function startGameLoop() {
            gameRunning = true;
            lastPickupSpawn = Date.now();
            animate();
        }

        function animate() {
            if (!gameRunning) return;
            requestAnimationFrame(animate);
            
            // Player movement
            player.velocity.x = 0;
            player.velocity.z = 0;
            
            if (keys['w']) player.velocity.z -= player.speed;
            if (keys['s']) player.velocity.z += player.speed;
            if (keys['a']) player.velocity.x -= player.speed;
            if (keys['d']) player.velocity.x += player.speed;
            
            // Normalize diagonal
            if (player.velocity.x !== 0 && player.velocity.z !== 0) {
                const len = Math.sqrt(player.velocity.x ** 2 + player.velocity.z ** 2);
                player.velocity.x = (player.velocity.x / len) * player.speed;
                player.velocity.z = (player.velocity.z / len) * player.speed;
            }
            
            player.mesh.position.x += player.velocity.x;
            player.mesh.position.z += player.velocity.z;
            
            // Check collisions with obstacles and towers
            let collided = false;
            
            // Check tower collision
            [playerTower, enemyTower].forEach(tower => {
                const dist = Math.sqrt(
                    Math.pow(player.mesh.position.x - tower.mesh.position.x, 2) +
                    Math.pow(player.mesh.position.z - tower.mesh.position.z, 2)
                );
                if (dist < (tower.mesh.userData.collisionRadius || 3) + 1) {
                    collided = true;
                }
            });
            
            // Check obstacle collision
            obstacles.forEach(obstacle => {
                const dist = Math.sqrt(
                    Math.pow(player.mesh.position.x - obstacle.position.x, 2) +
                    Math.pow(player.mesh.position.z - obstacle.position.z, 2)
                );
                const collisionDist = obstacle.userData.scale ? obstacle.userData.scale + 1 : 2;
                if (dist < collisionDist) {
                    collided = true;
                }
            });
            
            // If collided, revert position
            if (collided) {
                player.mesh.position.x -= player.velocity.x;
                player.mesh.position.z -= player.velocity.z;
            }
            
            // Spawn pickups every 5 seconds
            const currentTime = Date.now();
            if (currentTime - lastPickupSpawn > pickupSpawnInterval) {
                spawnRandomPickup();
                lastPickupSpawn = currentTime;
            }
            
            // Check pickup collection and expiration
            for (let i = pickups.length - 1; i >= 0; i--) {
                const pickup = pickups[i];
                
                // Check if pickup has expired (20 seconds)
                if (currentTime - pickup.userData.spawnTime > pickup.userData.lifetime) {
                    scene.remove(pickup);
                    pickups.splice(i, 1);
                    continue;
                }
                
                // Check if player collected it
                const dist = Math.sqrt(
                    Math.pow(player.mesh.position.x - pickup.position.x, 2) +
                    Math.pow(player.mesh.position.z - pickup.position.z, 2)
                );
                
                if (dist < pickup.userData.pickupRadius) {
                    if (pickup.userData.type === 'health') {
                        player.health = Math.min(player.maxHealth, player.health + pickup.userData.amount);
                        showNotification(`+${pickup.userData.amount} Health!`);
                    } else if (pickup.userData.type === 'stamina') {
                        player.stamina = Math.min(player.maxStamina, player.stamina + pickup.userData.amount);
                        showNotification(`+${pickup.userData.amount} Stamina!`);
                    }
                    
                    scene.remove(pickup);
                    pickups.splice(i, 1);
                }
            }
            
            // Bounds
            player.mesh.position.x = Math.max(-95, Math.min(95, player.mesh.position.x));
            player.mesh.position.z = Math.max(-45, Math.min(45, player.mesh.position.z));
            
            // Rotate to mouse
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mousePos, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            
            const lookDir = new THREE.Vector3().subVectors(target, player.mesh.position);
            player.mesh.rotation.y = Math.atan2(lookDir.x, lookDir.z);
            
            // Camera follow
            camera.position.x = player.mesh.position.x + cameraOffset.x;
            camera.position.y = cameraOffset.y;
            camera.position.z = player.mesh.position.z + cameraOffset.z;
            camera.lookAt(player.mesh.position);
            
            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.position.add(proj.userData.velocity);
                proj.userData.lifetime--;
                
                if (proj.userData.lifetime <= 0) {
                    scene.remove(proj);
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // Check collision with obstacles (trees, rocks)
                for (let j = obstacles.length - 1; j >= 0; j--) {
                    const obstacle = obstacles[j];
                    const dist = proj.position.distanceTo(obstacle.position);
                    const collisionDist = obstacle.userData.scale ? obstacle.userData.scale + 0.5 : 2;
                    
                    if (dist < collisionDist) {
                        obstacle.userData.health--;
                        
                        // Visual feedback - flash
                        if (obstacle.children && obstacle.children[0]) {
                            const originalColor = obstacle.children[0].material.color.clone();
                            obstacle.children[0].material.color.set(0xffffff);
                            setTimeout(() => {
                                if (obstacle.children[0]) {
                                    obstacle.children[0].material.color.copy(originalColor);
                                }
                            }, 100);
                        } else if (obstacle.material) {
                            const originalColor = obstacle.material.color.clone();
                            obstacle.material.color.set(0xffffff);
                            setTimeout(() => {
                                obstacle.material.color.copy(originalColor);
                            }, 100);
                        }
                        
                        // Destroy obstacle if health depleted
                        if (obstacle.userData.health <= 0) {
                            scene.remove(obstacle);
                            obstacles.splice(j, 1);
                        }
                        
                        scene.remove(proj);
                        projectiles.splice(i, 1);
                        break;
                    }
                }
                
                if (!proj.parent) continue; // Already removed
                
                // Check collision with towers
                const checkTowerCollision = (tower, isPlayerTower) => {
                    if (proj.userData.owner.isPlayer === isPlayerTower) return; // Don't hit own tower
                    
                    const dist = proj.position.distanceTo(tower.mesh.position);
                    if (dist < 3) {
                        tower.health -= proj.userData.damage;
                        
                        // Visual feedback
                        const originalColor = tower.mesh.children[0].material.color.clone();
                        tower.mesh.children[0].material.color.set(0xffffff);
                        setTimeout(() => {
                            tower.mesh.children[0].material.color.copy(originalColor);
                        }, 100);
                        
                        scene.remove(proj);
                        projectiles.splice(i, 1);
                        
                        if (tower.health <= 0) {
                            checkGameOver();
                        }
                    }
                };
                
                if (proj.parent) {
                    checkTowerCollision(playerTower, true);
                    checkTowerCollision(enemyTower, false);
                }
                
                if (!proj.parent) continue;
                
                // Check collision with enemy (original code)
                const targets = proj.userData.owner.isPlayer ? 
                    [enemy] : [player];
                
                targets.forEach(target => {
                    if (!proj.parent) return;
                    const dist = proj.position.distanceTo(target.mesh.position);
                    if (dist < 2) {
                        if (!target.shielded) {
                            target.health -= proj.userData.damage;
                            checkGameOver();
                        }
                        scene.remove(proj);
                        projectiles.splice(i, 1);
                    }
                });
            }
            
            // Stamina regen
            player.stamina = Math.min(100, player.stamina + 0.1);
            
            // Update UI
            updateUI();
            
            renderer.render(scene, camera);
        }

        // Update UI
        function updateUI() {
            document.getElementById('playerHP').textContent = Math.floor(player.health);
            document.getElementById('playerStamina').textContent = Math.floor(player.stamina);
            document.getElementById('playerHealthFill').style.width = (player.health / player.maxHealth * 100) + '%';
            document.getElementById('playerStaminaFill').style.width = (player.stamina / player.maxStamina * 100) + '%';
            
            document.getElementById('playerTowerHP').textContent = Math.floor(playerTower.health);
            document.getElementById('enemyTowerHP').textContent = Math.floor(enemyTower.health);
            document.getElementById('playerTowerFill').style.width = (playerTower.health / playerTower.maxHealth * 100) + '%';
            document.getElementById('enemyTowerFill').style.width = (enemyTower.health / enemyTower.maxHealth * 100) + '%';
        }

        // Show Notification
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.style.position = 'fixed';
            notification.style.top = '50%';
            notification.style.left = '50%';
            notification.style.transform = 'translate(-50%, -50%)';
            notification.style.background = 'rgba(0, 0, 0, 0.9)';
            notification.style.border = '2px solid #00d4ff';
            notification.style.borderRadius = '10px';
            notification.style.padding = '20px 40px';
            notification.style.fontFamily = 'Orbitron, sans-serif';
            notification.style.fontSize = '1.2em';
            notification.style.color = 'white';
            notification.style.zIndex = '3000';
            notification.style.pointerEvents = 'none';
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 2000);
        }

        // Check Game Over
        function checkGameOver() {
            if (player.health <= 0 || playerTower.health <= 0) {
                gameRunning = false;
                document.getElementById('defeatScreen').style.display = 'flex';
            }
            if (enemy.health <= 0 || enemyTower.health <= 0) {
                gameRunning = false;
                document.getElementById('victoryScreen').style.display = 'flex';
            }
        }

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        // Show main menu on load (removed auto skill selection)
    </script>
</body>
</html>
