<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trinari vs Chaos & Guardians (PC only!)</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(to right, rgba(0,100,255,0.2), rgba(0,255,100,0.2), rgba(255,50,50,0.2)), #0a0a0a;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            overflow-x: hidden;
            -webkit-user-select: none;
            user-select: none;
        }

        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #FFD700;
            color: #FFD700;
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
        }

        .back-button:hover {
            background: rgba(255, 215, 0, 0.2);
            transform: translateX(-5px);
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.5);
        }

        h1 { 
            color: #FFD700; 
            text-shadow: 0 0 20px rgba(255,215,0,0.8);
            margin-top: 20px;
        }

        canvas {
            display: block;
            margin: 20px auto;
            background: #1a1a2e;
            border: 4px solid #FFD700;
            border-radius: 10px;
            cursor: crosshair;
            max-width: 100%;
            height: auto;
            touch-action: none;
        }

        button {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }

        button:hover { 
            transform: scale(1.05); 
            box-shadow: 0 5px 20px rgba(255,215,0,0.5); 
        }

        button:disabled { 
            opacity: 0.5; 
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px;
            flex-wrap: wrap;
        }

        .stat {
            background: rgba(0,0,0,0.7);
            padding: 15px 25px;
            border-radius: 10px;
            border: 3px solid;
        }

        .stat.health { border-color: #00FF64; }
        .stat.wave { border-color: #c084fc; }
        .stat.kills { border-color: #FFD700; }
        .stat-value { font-size: 2rem; font-weight: bold; }

        .abilities {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 15px;
            flex-wrap: wrap;
        }

        .ability {
            background: rgba(0,0,0,0.7);
            border: 2px solid #FFD700;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .ability:hover:not(.cooldown) { 
            background: rgba(255,215,0,0.2); 
        }

        .ability.cooldown { 
            opacity: 0.3; 
            cursor: not-allowed; 
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-overlay.hidden {
            display: none;
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(10, 10, 10, 0.95));
            border: 3px solid #FFD700;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid rgba(255, 0, 0, 0.5);
            color: #ff4444;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            background: rgba(255, 0, 0, 0.4);
            border-color: #ff0000;
            transform: rotate(90deg);
        }

        .modal-title {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: #FFD700;
            margin-bottom: 20px;
        }

        .modal-text {
            color: #bbb;
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .name-input {
            width: 100%;
            padding: 15px;
            font-size: 1.1rem;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            color: white;
            text-align: center;
            margin-bottom: 20px;
            font-family: 'Inter', sans-serif;
        }

        .name-input:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .leaderboard-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #FFD700;
            color: #FFD700;
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 1000;
        }

        .leaderboard-button:hover {
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.5);
        }

        .leaderboard-modal {
            max-width: 800px;
            width: 95%;
        }

        .leaderboard-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
        }

        .tab-button {
            padding: 12px 30px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 25px;
            color: #888;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .tab-button.active {
            background: rgba(255, 215, 0, 0.2);
            border-color: #FFD700;
            color: #FFD700;
        }

        .leaderboard-content {
            max-height: 400px;
            overflow-y: auto;
        }

        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
        }

        .leaderboard-table th {
            background: rgba(255, 215, 0, 0.1);
            color: #FFD700;
            padding: 15px;
            text-align: left;
            font-weight: 700;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
        }

        .leaderboard-table td {
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #ccc;
        }

        .leaderboard-table tr:hover {
            background: rgba(255, 215, 0, 0.05);
        }

        .rank-badge {
            display: inline-block;
            width: 30px;
            height: 30px;
            line-height: 30px;
            border-radius: 50%;
            text-align: center;
            font-weight: bold;
        }

        .rank-1 {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
        }

        .rank-2 {
            background: linear-gradient(135deg, #C0C0C0, #A8A8A8);
            color: #000;
        }

        .rank-3 {
            background: linear-gradient(135deg, #CD7F32, #B87333);
            color: #000;
        }

        .rank-other {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }

        .empty-leaderboard {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #FFD700;
        }

        .joystick-area {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 215, 0, 0.3);
            border-radius: 50%;
            display: none;
        }

        .joystick-knob {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 215, 0, 0.6);
            border: 3px solid #FFD700;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .mobile-ability-buttons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none;
            flex-direction: column;
            gap: 10px;
        }

        .mobile-ability-btn {
            width: 70px;
            height: 70px;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #FFD700;
            border-radius: 50%;
            color: #FFD700;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            touch-action: manipulation;
        }

        .mobile-ability-btn:active {
            transform: scale(0.9);
            background: rgba(255, 215, 0, 0.3);
        }

        .mobile-ability-btn.cooldown {
            opacity: 0.3;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .back-button {
                top: 10px;
                left: 10px;
                padding: 8px 16px;
                font-size: 0.85rem;
            }

            .leaderboard-button {
                top: 60px;
                right: 10px;
                padding: 8px 16px;
                font-size: 0.85rem;
            }

            h1 {
                font-size: 1.3rem;
                margin-top: 100px;
                margin-bottom: 10px;
            }

            canvas {
                width: 100% !important;
                height: auto !important;
                max-width: 100vw;
            }

            .stats {
                gap: 10px;
                margin: 10px 0;
            }

            .stat {
                padding: 10px 15px;
            }

            .stat-value {
                font-size: 1.5rem;
            }

            .abilities {
                display: none;
            }

            button {
                padding: 12px 30px;
                font-size: 1rem;
            }

            .joystick-area,
            .mobile-ability-buttons {
                display: flex;
            }

            .modal-content {
                padding: 20px;
                max-width: 90%;
            }

            .modal-title {
                font-size: 1.5rem;
            }

            .leaderboard-table th,
            .leaderboard-table td {
                padding: 10px 8px;
                font-size: 0.9rem;
            }
        }

        .firebase-notice {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 20px auto;
            max-width: 600px;
            color: #FFD700;
        }

        .firebase-notice strong {
            display: block;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <button class="back-button" onclick="window.history.back()">
        ‚Üê Back
    </button>

    <button class="leaderboard-button" onclick="showLeaderboard()">
        üèÜ Leaderboard
    </button>

    <!-- Firebase Configuration Notice -->
    <div class="firebase-notice">
        <strong>‚ö†Ô∏è Firebase Setup Required</strong>
        To enable the global leaderboard, you need to configure Firebase. See instructions in the code comments.
    </div>

    <!-- Player Name Modal -->
    <div id="nameModal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close" onclick="closeNameModal()">‚úï</button>
            <div style="width: 120px; height: 120px; background: linear-gradient(135deg, #00FF64, #5a8a4a); border-radius: 50%; margin: 0 auto 20px; display: flex; align-items: center; justify-content: center; border: 3px solid #FFD700; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); font-size: 4rem;">üåø</div>
            <h2 class="modal-title">üåø Welcome, Trinari! üåø</h2>
            <p class="modal-text">
                Enter your name to begin your defense of the forest.<br>
                Your scores will be recorded on the leaderboard!
            </p>
            <input 
                type="text" 
                id="playerNameInput" 
                class="name-input" 
                placeholder="Enter your name..."
                maxlength="20"
                onkeypress="if(event.key === 'Enter') submitName()"
            >
            <div class="modal-buttons">
                <button onclick="submitName()">Start Adventure</button>
            </div>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboardModal" class="modal-overlay hidden">
        <div class="modal-content leaderboard-modal">
            <button class="modal-close" onclick="closeLeaderboard()">‚úï</button>
            <h2 class="modal-title">üèÜ Hall of Legends üèÜ</h2>
            
            <div class="leaderboard-tabs">
                <button class="tab-button active" onclick="switchTab(event, 'kills')">‚öîÔ∏è Most Kills</button>
                <button class="tab-button" onclick="switchTab(event, 'survival')">‚è±Ô∏è Longest Survival</button>
            </div>

            <div class="leaderboard-content" id="leaderboardContent">
                <div class="loading">Loading leaderboard...</div>
            </div>

            <div class="modal-buttons" style="margin-top: 30px;">
                <button onclick="closeLeaderboard()">Close</button>
            </div>
        </div>
    </div>

    <h1>üåø TRINARI VS CHAOS & GUARDIANS üõ°Ô∏è</h1>
    
    <div class="stats">
        <div class="stat health">
            <div>üíö Health</div>
            <div class="stat-value" style="color: #00FF64;" id="health">10</div>
        </div>
        <div class="stat wave">
            <div>üåä Wave</div>
            <div class="stat-value" style="color: #c084fc;" id="wave">1</div>
        </div>
        <div class="stat kills">
            <div>‚öîÔ∏è Kills</div>
            <div class="stat-value" style="color: #FFD700;" id="kills">0</div>
        </div>
    </div>

    <div class="abilities">
        <div class="ability" style="cursor: default; border-color: #8B5CF6;">
            ‚ú® ARCANE BOLT (Click/Tap)<br><small style="color: #c084fc;">Always Ready</small>
        </div>
        <div class="ability" onclick="useDash()" id="dashBtn">
            ‚ö° DASH (Space)<br><small id="dashCD">Ready</small>
        </div>
        <div class="ability" onclick="useSpecial()" id="specialBtn">
            üåü AUTO-FIRE (E)<br><small id="specialCD">Ready</small>
        </div>
        <div class="ability" onclick="useUltimate()" id="ultBtn">
            üí• ULTIMATE (Q)<br><small id="ultCD">Ready</small>
        </div>
    </div>

    <button onclick="startGame()" id="startBtn">üéÆ START GAME</button>
    
    <canvas id="canvas" width="800" height="600"></canvas>

    <!-- Mobile Controls -->
    <div class="joystick-area" id="joystick">
        <div class="joystick-knob" id="joystickKnob"></div>
    </div>

    <div class="mobile-ability-buttons">
        <div class="mobile-ability-btn" id="mobileDash" ontouchstart="event.stopPropagation(); useDash();">‚ö°</div>
        <div class="mobile-ability-btn" id="mobileSpecial" ontouchstart="event.stopPropagation(); useSpecial();">üåü</div>
        <div class="mobile-ability-btn" id="mobileUlt" ontouchstart="event.stopPropagation(); useUltimate();">üí•</div>
    </div>

    <!-- Firebase SDKs - Updated versions -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

    <script>
        // ============================================
        // FIREBASE CONFIGURATION
        // ============================================
        
        const firebaseConfig = {
            apiKey: "AIzaSyBdfIELtI9MoF6h0xMOEgCnC7_EZlckEz8",
            authDomain: "cronos-legends.firebaseapp.com",
            projectId: "cronos-legends",
            storageBucket: "cronos-legends.firebasestorage.app",
            messagingSenderId: "454787291077",
            appId: "1:454787291077:web:e99237983f33edbd6f1dac"
        };

        // Initialize Firebase with error handling
        let db = null;
        let firebaseEnabled = false;

        // Wait for Firebase to load
        function initializeFirebase() {
            try {
                if (typeof firebase === 'undefined') {
                    console.error("‚ùå Firebase SDK not loaded");
                    return;
                }
                
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                firebaseEnabled = true;
                console.log("‚úÖ Firebase connected successfully!");
                document.querySelector('.firebase-notice').style.display = 'none';
            } catch (error) {
                console.error("‚ùå Firebase initialization error:", error);
                console.log("Falling back to localStorage");
            }
        }

        // Initialize after page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeFirebase);
        } else {
            initializeFirebase();
        }
        
        // ============================================
        // LEADERBOARD FUNCTIONS
        // ============================================

        async function getLeaderboard() {
            if (firebaseEnabled && db) {
                const leaderboard = { kills: [], survival: [] };
                
                try {
                    // Get kills leaderboard from Firestore
                    const killsSnapshot = await db.collection('trinari_leaderboard')
                        .orderBy('kills', 'desc')
                        .limit(100)
                        .get();
                    
                    killsSnapshot.forEach(doc => {
                        leaderboard.kills.push(doc.data());
                    });
                    
                    // Get survival leaderboard from Firestore
                    const survivalSnapshot = await db.collection('trinari_leaderboard')
                        .orderBy('survivalTime', 'desc')
                        .limit(100)
                        .get();
                    
                    survivalSnapshot.forEach(doc => {
                        leaderboard.survival.push(doc.data());
                    });
                    
                    // Sort survival by survivalTime
                    leaderboard.survival.sort((a, b) => b.survivalTime - a.survivalTime);
                    
                    return leaderboard;
                } catch (error) {
                    console.error('Error loading leaderboard from Firebase:', error);
                    // Fallback to localStorage
                    return getLocalLeaderboard();
                }
            } else {
                // Use localStorage as fallback
                return getLocalLeaderboard();
            }
        }

        function getLocalLeaderboard() {
            const stored = localStorage.getItem('trinariLeaderboard');
            return stored ? JSON.parse(stored) : { kills: [], survival: [] };
        }

        async function saveScore(kills, wave, survivalTime) {
            if (!playerName) return;
            
            const entry = {
                name: playerName,
                kills: kills,
                wave: wave,
                survivalTime: survivalTime,
                date: new Date().toISOString(),
                timestamp: firebase.firestore.FieldValue.serverTimestamp ? firebase.firestore.FieldValue.serverTimestamp() : new Date()
            };
            
            if (firebaseEnabled && db) {
                try {
                    await db.collection('trinari_leaderboard').add(entry);
                    console.log('‚úÖ Score saved to Firebase!');
                } catch (error) {
                    console.error('‚ùå Error saving score to Firebase:', error);
                    // Fallback to localStorage
                    saveLocalScore(entry);
                }
            } else {
                // Use localStorage as fallback
                saveLocalScore(entry);
            }
        }

        function saveLocalScore(entry) {
            const leaderboard = getLocalLeaderboard();
            
            leaderboard.kills.push(entry);
            leaderboard.kills.sort((a, b) => b.kills - a.kills);
            leaderboard.kills = leaderboard.kills.slice(0, 100);
            
            leaderboard.survival.push(entry);
            leaderboard.survival.sort((a, b) => b.survivalTime - a.survivalTime);
            leaderboard.survival = leaderboard.survival.slice(0, 100);
            
            localStorage.setItem('trinariLeaderboard', JSON.stringify(leaderboard));
            console.log('üíæ Score saved to localStorage');
        }

        async function displayLeaderboard(type) {
            const content = document.getElementById('leaderboardContent');
            content.innerHTML = '<div class="loading">Loading leaderboard...</div>';
            
            const leaderboard = await getLeaderboard();
            const data = leaderboard[type] || [];
            
            if (data.length === 0) {
                content.innerHTML = '<div class="empty-leaderboard">No records yet. Be the first to set a score!</div>';
                return;
            }
            
            let html = '<table class="leaderboard-table"><thead><tr>';
            html += '<th>Rank</th>';
            html += '<th>Player</th>';
            
            if (type === 'kills') {
                html += '<th>Kills</th><th>Wave</th>';
            } else {
                html += '<th>Survival Time</th><th>Wave</th>';
            }
            
            html += '<th>Date</th></tr></thead><tbody>';
            
            data.forEach((entry, index) => {
                const rank = index + 1;
                let rankClass = 'rank-other';
                if (rank === 1) rankClass = 'rank-1';
                else if (rank === 2) rankClass = 'rank-2';
                else if (rank === 3) rankClass = 'rank-3';
                
                html += '<tr>';
                html += `<td><span class="rank-badge ${rankClass}">${rank}</span></td>`;
                html += `<td><strong>${entry.name}</strong></td>`;
                
                if (type === 'kills') {
                    html += `<td>${entry.kills}</td>`;
                } else {
                    html += `<td>${formatTime(entry.survivalTime)}</td>`;
                }
                
                html += `<td>${entry.wave}</td>`;
                html += `<td>${new Date(entry.date).toLocaleDateString()}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            content.innerHTML = html;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}m ${secs}s`;
        }

        // ============================================
        // UI FUNCTIONS
        // ============================================

        let playerName = '';
        let gameStartTime = 0;
        let currentLeaderboardTab = 'kills';

        function submitName() {
            const input = document.getElementById('playerNameInput');
            const name = input.value.trim();
            
            if (name === '') {
                alert('Please enter a name to continue!');
                return;
            }
            
            playerName = name;
            document.getElementById('nameModal').classList.add('hidden');
            document.getElementById('startBtn').disabled = false;
        }

        function closeNameModal() {
            if (confirm('Are you sure you want to exit?')) {
                window.history.back();
            }
        }

        async function showLeaderboard() {
            document.getElementById('leaderboardModal').classList.remove('hidden');
            await displayLeaderboard(currentLeaderboardTab);
        }

        function closeLeaderboard() {
            document.getElementById('leaderboardModal').classList.add('hidden');
        }

        async function switchTab(event, tab) {
            currentLeaderboardTab = tab;
            
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            await displayLeaderboard(tab);
        }

        // ============================================
        // GAME CODE
        // ============================================

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let joystickActive = false;
        let joystickAngle = 0;
        let joystickDistance = 0;
        let touchControls = {
            moveX: 0,
            moveY: 0,
            shooting: false,
            shootX: 0,
            shootY: 0
        };
        
        let game = {
            running: false,
            player: { x: 400, y: 300, size: 25, speed: 3, health: 10, maxHealth: 10, invulnerable: 0, dashActive: 0 },
            enemies: [],
            projectiles: [],
            enemyProjectiles: [],
            particles: [],
            hearts: [],
            wave: 1,
            kills: 0,
            keys: {},
            dashCooldown: 0,
            ultimateCooldown: 0,
            specialCooldown: 0,
            autoFireActive: 0,
            autoFireCount: 0,
            screenShake: 0,
            shakeX: 0,
            shakeY: 0,
            waveColor: '#FFD700',
            ultimateRings: [],
            mouseX: 400,
            mouseY: 300
        };

        function startGame() {
            if (!playerName) {
                alert('Please enter your name first!');
                return;
            }
            
            game.running = true;
            gameStartTime = Date.now();
            game.player = { x: 400, y: 300, size: 25, speed: 3, health: 10, maxHealth: 10, invulnerable: 0, dashActive: 0 };
            game.enemies = createEnemies(1);
            game.projectiles = [];
            game.enemyProjectiles = [];
            game.particles = [];
            game.wave = 1;
            game.kills = 0;
            game.keys = {};
            game.dashCooldown = 0;
            game.ultimateCooldown = 0;
            game.screenShake = 0;
            game.waveColor = '#FFD700';
            game.ultimateRings = [];
            
            document.getElementById('startBtn').disabled = true;
            updateUI();
            gameLoop();
        }

        function createEnemies(wave) {
            const enemies = [];
            const count = 2 + wave;
            const weapons = ['sword', 'bow', 'magic'];
            
            if (wave % 5 === 0) {
                const isChaos = Math.random() > 0.5;
                enemies.push({
                    x: 400, y: -50, size: 45, speed: 0.8,
                    health: wave * 5, maxHealth: wave * 5,
                    type: 'boss',
                    faction: isChaos ? 'chaos' : 'guardian',
                    weapon: 'sword', attackCooldown: 0
                });
            }
            
            for (let i = 0; i < count; i++) {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                if (side === 0) { x = Math.random() * 800; y = -20; }
                else if (side === 1) { x = 820; y = Math.random() * 600; }
                else if (side === 2) { x = Math.random() * 800; y = 620; }
                else { x = -20; y = Math.random() * 600; }
                
                const isGuardian = Math.random() > 0.5;
                
                enemies.push({
                    x, y, size: 22,
                    speed: 1 + wave * 0.1,
                    health: 1 + Math.floor(wave / 3),
                    maxHealth: 1 + Math.floor(wave / 3),
                    type: 'normal',
                    faction: isGuardian ? 'guardian' : 'chaos',
                    weapon: weapons[i % 3],
                    attackCooldown: Math.random() * 60
                });
            }
            return enemies;
        }

        function useDash() {
            if (game.dashCooldown <= 0 && game.running) {
                game.player.dashActive = 15;
                game.player.invulnerable = 15;
                game.dashCooldown = 120;
                createParticles(game.player.x, game.player.y, '#00FF64', 20);
            }
        }

        function useUltimate() {
            if (game.ultimateCooldown <= 0 && game.running) {
                game.ultimateCooldown = 600;
                game.screenShake = 30;
                
                const dx = game.mouseX - game.player.x;
                const dy = game.mouseY - game.player.y;
                const angle = Math.atan2(dy, dx);
                const staffLength = 35;
                const staffX = game.player.x + Math.cos(angle) * staffLength;
                const staffY = game.player.y + Math.sin(angle) * staffLength;
                
                game.ultimateRings.push({ x: staffX, y: staffY, radius: 0, maxRadius: 300, life: 60 });
                createParticles(staffX, staffY, game.waveColor, 100);
                
                game.enemies.forEach(e => {
                    const dist = Math.sqrt((e.x - staffX) ** 2 + (e.y - staffY) ** 2);
                    if (dist < 300) {
                        e.health -= 2.5;
                        createParticles(e.x, e.y, '#FF0000', 20);
                    }
                });
            }
        }

        function useSpecial() {
            if (game.specialCooldown <= 0 && game.running) {
                game.specialCooldown = 900;
                game.autoFireActive = 120;
                game.autoFireCount = 20;
                createParticles(game.player.x, game.player.y, '#FFD700', 30);
            }
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                game.particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * 4 + 2,
                    color, life: 30
                });
            }
        }

        function drawPlayer() {
            const alpha = game.player.invulnerable > 0 && Math.floor(Date.now() / 100) % 2 === 0 ? 0.5 : 1;
            ctx.globalAlpha = alpha;
            
            ctx.fillStyle = '#8B6F47';
            ctx.beginPath();
            ctx.arc(game.player.x, game.player.y + 5, game.player.size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#A0866F';
            ctx.fillRect(game.player.x - game.player.size * 0.6, game.player.y - game.player.size * 0.9, game.player.size * 1.2, game.player.size * 0.7);
            
            ctx.fillStyle = '#5a8a4a';
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.ellipse(game.player.x + (i - 2) * game.player.size * 0.25, game.player.y - game.player.size * 0.95, game.player.size * 0.2, game.player.size * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.fillStyle = '#00FFD0';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00FFD0';
            ctx.beginPath();
            ctx.arc(game.player.x - game.player.size * 0.3, game.player.y - game.player.size * 0.5, 5, 0, Math.PI * 2);
            ctx.arc(game.player.x + game.player.size * 0.3, game.player.y - game.player.size * 0.5, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            const dx = game.mouseX - game.player.x;
            const dy = game.mouseY - game.player.y;
            const angle = Math.atan2(dy, dx);
            const staffLength = 35;
            const staffX = game.player.x + Math.cos(angle) * staffLength;
            const staffY = game.player.y + Math.sin(angle) * staffLength;
            
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(game.player.x, game.player.y);
            ctx.lineTo(staffX, staffY);
            ctx.stroke();
            
            ctx.fillStyle = '#00FF64';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00FF64';
            ctx.beginPath();
            ctx.arc(staffX, staffY, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = game.waveColor;
            ctx.lineWidth = 2;
            ctx.shadowBlur = 15;
            ctx.shadowColor = game.waveColor;
            ctx.beginPath();
            ctx.arc(staffX, staffY, 8 + Math.sin(Date.now() / 100) * 2, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        }

        function drawEnemy(e) {
            ctx.save();
            
            const angleToPlayer = Math.atan2(game.player.y - e.y, game.player.x - e.x);
            
            if (e.faction === 'chaos') {
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#e8e8d8';
                ctx.beginPath();
                ctx.arc(e.x, e.y - e.size * 0.2, e.size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FF0000';
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#FF0000';
                ctx.beginPath();
                ctx.arc(e.x - e.size * 0.25, e.y - e.size * 0.25, e.size * 0.08, 0, Math.PI * 2);
                ctx.arc(e.x + e.size * 0.25, e.y - e.size * 0.25, e.size * 0.08, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                if (e.weapon === 'sword') {
                    const swordWave = Math.sin(Date.now() / 200) * 0.15;
                    const swordLength = e.size * 1.5;
                    const swordEndX = e.x + Math.cos(angleToPlayer + swordWave) * swordLength;
                    const swordEndY = e.y + Math.sin(angleToPlayer + swordWave) * swordLength;
                    
                    ctx.strokeStyle = '#8B0000';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#FF0000';
                    ctx.beginPath();
                    ctx.moveTo(e.x + Math.cos(angleToPlayer) * e.size * 0.5, e.y + Math.sin(angleToPlayer) * e.size * 0.5);
                    ctx.lineTo(swordEndX, swordEndY);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                } else if (e.weapon === 'bow') {
                    const bowX = e.x + Math.cos(angleToPlayer) * (e.size + 8);
                    const bowY = e.y + Math.sin(angleToPlayer) * (e.size + 8);
                    ctx.save();
                    ctx.translate(bowX, bowY);
                    ctx.rotate(angleToPlayer);
                    ctx.strokeStyle = '#4a2a1a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, -Math.PI/2, Math.PI/2, false);
                    ctx.stroke();
                    ctx.restore();
                } else {
                    const orbX = e.x + Math.cos(angleToPlayer) * (e.size + 10);
                    const orbY = e.y + Math.sin(angleToPlayer) * (e.size + 10);
                    ctx.fillStyle = '#8B00FF';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#8B00FF';
                    ctx.beginPath();
                    ctx.arc(orbX, orbY, 7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
            } else {
                ctx.fillStyle = '#3a5a7a';
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#c8b5a5';
                ctx.beginPath();
                ctx.arc(e.x, e.y - e.size * 0.2, e.size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                if (e.weapon === 'sword') {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(e.x, e.y - e.size * 0.5, e.size * 0.4, 0, Math.PI);
                    ctx.fill();
                }
                
                ctx.fillStyle = '#00BFFF';
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#00BFFF';
                ctx.beginPath();
                ctx.arc(e.x - e.size * 0.25, e.y - e.size * 0.25, e.size * 0.1, 0, Math.PI * 2);
                ctx.arc(e.x + e.size * 0.25, e.y - e.size * 0.25, e.size * 0.1, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                if (e.weapon === 'sword') {
                    const spearWave = Math.sin(Date.now() / 200) * 0.15;
                    const spearLength = e.size * 1.8;
                    const spearEndX = e.x + Math.cos(angleToPlayer + spearWave) * spearLength;
                    const spearEndY = e.y + Math.sin(angleToPlayer + spearWave) * spearLength;
                    
                    ctx.strokeStyle = '#8B7355';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(e.x + Math.cos(angleToPlayer) * e.size * 0.5, e.y + Math.sin(angleToPlayer) * e.size * 0.5);
                    ctx.lineTo(spearEndX, spearEndY);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#C0D0E0';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#00BFFF';
                    ctx.beginPath();
                    ctx.arc(spearEndX, spearEndY, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (e.weapon === 'bow') {
                    const bowX = e.x + Math.cos(angleToPlayer) * (e.size + 8);
                    const bowY = e.y + Math.sin(angleToPlayer) * (e.size + 8);
                    ctx.save();
                    ctx.translate(bowX, bowY);
                    ctx.rotate(angleToPlayer);
                    ctx.strokeStyle = '#8B7355';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, -Math.PI/2, Math.PI/2, false);
                    ctx.stroke();
                    ctx.restore();
                } else {
                    ctx.fillStyle = '#6a4a9a';
                    ctx.beginPath();
                    ctx.moveTo(e.x, e.y - e.size * 0.9);
                    ctx.lineTo(e.x - e.size * 0.4, e.y - e.size * 0.4);
                    ctx.lineTo(e.x + e.size * 0.4, e.y - e.size * 0.4);
                    ctx.fill();
                    
                    const orbX = e.x + Math.cos(angleToPlayer) * (e.size + 10);
                    const orbY = e.y + Math.sin(angleToPlayer) * (e.size + 10);
                    ctx.fillStyle = '#7B68EE';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#7B68EE';
                    ctx.beginPath();
                    ctx.arc(orbX, orbY, 7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            
            if (e.type === 'boss') {
                const bossColor = e.faction === 'chaos' ? '#FFD700' : '#00BFFF';
                ctx.strokeStyle = bossColor;
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = bossColor;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size + 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            ctx.fillStyle = '#000';
            ctx.fillRect(e.x - 20, e.y + e.size + 5, 40, 4);
            const healthColor = e.faction === 'chaos' ? '#FF0000' : '#00BFFF';
            ctx.fillStyle = healthColor;
            ctx.fillRect(e.x - 20, e.y + e.size + 5, 40 * (e.health / e.maxHealth), 4);
            
            ctx.restore();
        }

        function gameLoop() {
            if (!game.running) return;
            
            if (game.screenShake > 0) {
                game.shakeX = (Math.random() - 0.5) * game.screenShake;
                game.shakeY = (Math.random() - 0.5) * game.screenShake;
                game.screenShake--;
            } else {
                game.shakeX = 0;
                game.shakeY = 0;
            }
            
            ctx.save();
            ctx.translate(game.shakeX, game.shakeY);
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, 800, 600);
            
            let speed = game.player.speed;
            if (game.player.dashActive > 0) {
                speed *= 3;
                game.player.dashActive--;
                createParticles(game.player.x, game.player.y, '#00FF64', 2);
            }
            
            if (game.keys.w || game.keys.ArrowUp) game.player.y -= speed;
            if (game.keys.s || game.keys.ArrowDown) game.player.y += speed;
            if (game.keys.a || game.keys.ArrowLeft) game.player.x -= speed;
            if (game.keys.d || game.keys.ArrowRight) game.player.x += speed;
            
            if (joystickActive) {
                game.player.x += touchControls.moveX * speed;
                game.player.y += touchControls.moveY * speed;
            }
            
            game.player.x = Math.max(25, Math.min(775, game.player.x));
            game.player.y = Math.max(25, Math.min(575, game.player.y));
            
            if (game.player.invulnerable > 0) game.player.invulnerable--;
            if (game.dashCooldown > 0) game.dashCooldown--;
            if (game.ultimateCooldown > 0) game.ultimateCooldown--;
            if (game.specialCooldown > 0) game.specialCooldown--;
            
            if (game.autoFireActive > 0) {
                game.autoFireActive--;
                if (game.autoFireCount > 0 && game.autoFireActive % 6 === 0) {
                    const dx = game.mouseX - game.player.x;
                    const dy = game.mouseY - game.player.y;
                    const angle = Math.atan2(dy, dx);
                    const staffX = game.player.x + Math.cos(angle) * 35;
                    const staffY = game.player.y + Math.sin(angle) * 35;
                    
                    let nearestEnemy = null;
                    let nearestDist = Infinity;
                    game.enemies.forEach(e => {
                        const dist = Math.sqrt((e.x - game.player.x) ** 2 + (e.y - game.player.y) ** 2);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = e;
                        }
                    });
                    
                    if (nearestEnemy) {
                        const shootDx = nearestEnemy.x - staffX;
                        const shootDy = nearestEnemy.y - staffY;
                        const shootDist = Math.sqrt(shootDx * shootDx + shootDy * shootDy);
                        
                        game.projectiles.push({
                            x: staffX, y: staffY,
                            vx: (shootDx / shootDist) * 7,
                            vy: (shootDy / shootDist) * 7,
                            size: 6
                        });
                        createParticles(staffX, staffY, game.waveColor, 3);
                        game.autoFireCount--;
                    }
                }
            }
            
            game.particles = game.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = (p.life / 30) * 0.5;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * 0.7, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                return p.life > 0;
            });
            
            game.ultimateRings = game.ultimateRings.filter(ring => {
                ring.radius += 10;
                ring.life--;
                ctx.strokeStyle = game.waveColor;
                ctx.lineWidth = 5;
                ctx.globalAlpha = ring.life / 60;
                ctx.beginPath();
                ctx.arc(ring.x, ring.y, ring.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
                return ring.life > 0 && ring.radius < ring.maxRadius;
            });
            
            game.enemies = game.enemies.filter(e => {
                const dx = game.player.x - e.x;
                const dy = game.player.y - e.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                e.attackCooldown--;
                
                if (e.weapon === 'sword') {
                    e.x += (dx / dist) * e.speed;
                    e.y += (dy / dist) * e.speed;
                    
                    const meleeRange = e.faction === 'chaos' ? e.size * 1.5 : e.size * 1.8;
                    if (dist < e.size + game.player.size + meleeRange * 0.5 && game.player.invulnerable === 0) {
                        game.player.health--;
                        game.player.invulnerable = 60;
                        game.screenShake = 15;
                        createParticles(game.player.x, game.player.y, '#FF0000', 10);
                        updateUI();
                        if (game.player.health <= 0) {
                            endGame();
                            return false;
                        }
                    }
                } else if (e.weapon === 'bow') {
                    if (dist > 250) {
                        e.x += (dx / dist) * e.speed;
                        e.y += (dy / dist) * e.speed;
                    } else if (dist < 180) {
                        e.x -= (dx / dist) * e.speed * 0.5;
                        e.y -= (dy / dist) * e.speed * 0.5;
                    }
                    if (e.attackCooldown <= 0 && dist < 400) {
                        const arrowAngle = Math.atan2(dy, dx);
                        game.enemyProjectiles.push({
                            x: e.x + Math.cos(arrowAngle) * (e.size + 8),
                            y: e.y + Math.sin(arrowAngle) * (e.size + 8),
                            vx: (dx / dist) * 5,
                            vy: (dy / dist) * 5,
                            size: 3,
                            color: '#8B4513',
                            angle: arrowAngle,
                            isArrow: true
                        });
                        e.attackCooldown = 90;
                    }
                } else if (e.weapon === 'magic') {
                    if (dist > 220) {
                        e.x += (dx / dist) * e.speed * 0.8;
                        e.y += (dy / dist) * e.speed * 0.8;
                    }
                    if (e.attackCooldown <= 0 && dist < 350) {
                        game.enemyProjectiles.push({
                            x: e.x, y: e.y,
                            vx: (dx / dist) * 3,
                            vy: (dy / dist) * 3,
                            size: 7, color: e.faction === 'chaos' ? '#8B00FF' : '#7B68EE'
                        });
                        e.attackCooldown = 120;
                    }
                }
                
                if (e.weapon !== 'sword' && dist < e.size + game.player.size && game.player.invulnerable === 0) {
                    game.player.health--;
                    game.player.invulnerable = 60;
                    game.screenShake = 15;
                    createParticles(game.player.x, game.player.y, '#FF0000', 10);
                    updateUI();
                    if (game.player.health <= 0) {
                        endGame();
                        return false;
                    }
                }
                
                drawEnemy(e);
                return e.health > 0;
            });
            
            game.enemyProjectiles = game.enemyProjectiles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                const dist = Math.sqrt((p.x - game.player.x) ** 2 + (p.y - game.player.y) ** 2);
                if (dist < game.player.size + p.size && game.player.invulnerable === 0) {
                    game.player.health--;
                    game.player.invulnerable = 60;
                    game.screenShake = 10;
                    createParticles(game.player.x, game.player.y, '#FF0000', 8);
                    updateUI();
                    if (game.player.health <= 0) {
                        endGame();
                        return false;
                    }
                    return false;
                }
                
                if (p.isArrow) {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.angle);
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-8, -2, 12, 4);
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.moveTo(4, 0);
                    ctx.lineTo(0, -3);
                    ctx.lineTo(0, 3);
                    ctx.fill();
                    ctx.restore();
                } else {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                return p.x > 0 && p.x < 800 && p.y > 0 && p.y < 600;
            });
            
            game.projectiles = game.projectiles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                
                for (let i = game.enemies.length - 1; i >= 0; i--) {
                    const e = game.enemies[i];
                    const dist = Math.sqrt((p.x - e.x) ** 2 + (p.y - e.y) ** 2);
                    if (dist < e.size + p.size) {
                        e.health--;
                        createParticles(p.x, p.y, '#FFD700', 5);
                        if (e.health <= 0) {
                            const deadX = e.x;
                            const deadY = e.y;
                            game.enemies.splice(i, 1);
                            game.kills++;
                            game.screenShake = 5;
                            createParticles(deadX, deadY, '#FFD700', 15);
                            
                            if (Math.random() < 0.1) {
                                game.hearts.push({
                                    x: deadX,
                                    y: deadY,
                                    life: 180,
                                    size: 12
                                });
                            }
                            
                            updateUI();
                        }
                        return false;
                    }
                }
                
                ctx.fillStyle = game.waveColor;
                ctx.shadowBlur = 8;
                ctx.shadowColor = game.waveColor;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                return p.x > 0 && p.x < 800 && p.y > 0 && p.y < 600;
            });
            
            game.hearts = game.hearts.filter(h => {
                h.life--;
                
                const dist = Math.sqrt((h.x - game.player.x) ** 2 + (h.y - game.player.y) ** 2);
                if (dist < game.player.size + h.size) {
                    if (game.player.health < game.player.maxHealth) {
                        game.player.health++;
                        updateUI();
                    }
                    createParticles(h.x, h.y, '#FF69B4', 15);
                    return false;
                }
                
                const shouldDraw = h.life > 60 || Math.floor(h.life / 10) % 2 === 0;
                
                if (shouldDraw) {
                    ctx.save();
                    ctx.fillStyle = '#FF1493';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#FF69B4';
                    
                    ctx.beginPath();
                    ctx.moveTo(h.x, h.y + h.size * 0.3);
                    ctx.bezierCurveTo(h.x, h.y, h.x - h.size * 0.5, h.y - h.size * 0.5, h.x - h.size, h.y + h.size * 0.3);
                    ctx.bezierCurveTo(h.x - h.size, h.y + h.size, h.x, h.y + h.size * 1.7, h.x, h.y + h.size * 1.7);
                    ctx.bezierCurveTo(h.x, h.y + h.size * 1.7, h.x + h.size, h.y + h.size, h.x + h.size, h.y + h.size * 0.3);
                    ctx.bezierCurveTo(h.x + h.size * 0.5, h.y - h.size * 0.5, h.x, h.y, h.x, h.y + h.size * 0.3);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
                
                return h.life > 0;
            });
            
            if (game.enemies.length === 0) {
                game.wave++;
                const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#95E1D3', '#F38181', '#AA96DA', '#FCBAD3'];
                game.waveColor = colors[(game.wave - 1) % colors.length];
                game.enemies = createEnemies(game.wave);
                game.screenShake = 20;
                updateUI();
            }
            
            updateUI();
            drawPlayer();
            ctx.restore();
            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            const survivalTime = Math.floor((Date.now() - gameStartTime) / 1000);
            
            saveScore(game.kills, game.wave, survivalTime);
            
            alert(`Game Over!\n\nPlayer: ${playerName}\nWaves Survived: ${game.wave}\nTotal Kills: ${game.kills}\nSurvival Time: ${formatTime(survivalTime)}\n\nYour score has been saved to the leaderboard!`);
            game.running = false;
            document.getElementById('startBtn').disabled = false;
        }

        function updateUI() {
            document.getElementById('health').textContent = game.player.health;
            document.getElementById('wave').textContent = game.wave;
            document.getElementById('kills').textContent = game.kills;
            
            const dashBtn = document.getElementById('dashBtn');
            const mobileDash = document.getElementById('mobileDash');
            if (game.dashCooldown > 0) {
                dashBtn.classList.add('cooldown');
                mobileDash.classList.add('cooldown');
                const secondsLeft = (game.dashCooldown / 60).toFixed(1);
                document.getElementById('dashCD').textContent = secondsLeft + 's';
            } else {
                dashBtn.classList.remove('cooldown');
                mobileDash.classList.remove('cooldown');
                document.getElementById('dashCD').textContent = 'Ready';
            }
            
            const specialBtn = document.getElementById('specialBtn');
            const mobileSpecial = document.getElementById('mobileSpecial');
            if (game.specialCooldown > 0) {
                specialBtn.classList.add('cooldown');
                mobileSpecial.classList.add('cooldown');
                const secondsLeft = (game.specialCooldown / 60).toFixed(1);
                document.getElementById('specialCD').textContent = secondsLeft + 's';
            } else {
                specialBtn.classList.remove('cooldown');
                mobileSpecial.classList.remove('cooldown');
                document.getElementById('specialCD').textContent = 'Ready';
            }
            
            const ultBtn = document.getElementById('ultBtn');
            const mobileUlt = document.getElementById('mobileUlt');
            if (game.ultimateCooldown > 0) {
                ultBtn.classList.add('cooldown');
                mobileUlt.classList.add('cooldown');
                const secondsLeft = (game.ultimateCooldown / 60).toFixed(1);
                document.getElementById('ultCD').textContent = secondsLeft + 's';
            } else {
                ultBtn.classList.remove('cooldown');
                mobileUlt.classList.remove('cooldown');
                document.getElementById('ultCD').textContent = 'Ready';
            }
        }

        // Event Listeners
        window.addEventListener('keydown', e => {
            if (document.activeElement.tagName === 'INPUT') {
                return;
            }
            
            game.keys[e.key] = true;
            if (e.key === ' ') { e.preventDefault(); useDash(); }
            if (e.key === 'q' || e.key === 'Q') { e.preventDefault(); useUltimate(); }
            if (e.key === 'e' || e.key === 'E') { e.preventDefault(); useSpecial(); }
        });
        
        window.addEventListener('keyup', e => {
            if (document.activeElement.tagName === 'INPUT') {
                return;
            }
            game.keys[e.key] = false;
        });

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            game.mouseX = e.clientX - rect.left;
            game.mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('click', e => {
            if (!game.running) return;
            
            const rect = canvas.getBoundingClientRect();
            const targetX = e.clientX - rect.left;
            const targetY = e.clientY - rect.top;
            
            const dx = game.mouseX - game.player.x;
            const dy = game.mouseY - game.player.y;
            const angle = Math.atan2(dy, dx);
            const staffX = game.player.x + Math.cos(angle) * 35;
            const staffY = game.player.y + Math.sin(angle) * 35;
            
            const shootDx = targetX - staffX;
            const shootDy = targetY - staffY;
            const shootDist = Math.sqrt(shootDx * shootDx + shootDy * shootDy);
            
            game.projectiles.push({
                x: staffX, y: staffY,
                vx: (shootDx / shootDist) * 6,
                vy: (shootDy / shootDist) * 6,
                size: 6
            });
            
            createParticles(staffX, staffY, game.waveColor, 5);
        });

        // Mobile Joystick Controls
        const joystick = document.getElementById('joystick');
        const joystickKnob = document.getElementById('joystickKnob');

        joystick.addEventListener('touchstart', handleJoystickStart, { passive: false });
        joystick.addEventListener('touchmove', handleJoystickMove, { passive: false });
        joystick.addEventListener('touchend', handleJoystickEnd, { passive: false });

        function handleJoystickStart(e) {
            e.preventDefault();
            e.stopPropagation();  // Prevent canvas from receiving this touch
            joystickActive = true;
        }

        function handleJoystickMove(e) {
            e.preventDefault();
            e.stopPropagation();  // Prevent canvas from receiving this touch
            if (!joystickActive) return;

            const touch = e.touches[0];
            const rect = joystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            let deltaX = touch.clientX - centerX;
            let deltaY = touch.clientY - centerY;

            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 45;

            if (distance > maxDistance) {
                deltaX = (deltaX / distance) * maxDistance;
                deltaY = (deltaY / distance) * maxDistance;
            }

            joystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

            touchControls.moveX = deltaX / maxDistance;
            touchControls.moveY = deltaY / maxDistance;
        }

        function handleJoystickEnd(e) {
            e.preventDefault();
            e.stopPropagation();  // Prevent canvas from receiving this touch
            joystickActive = false;
            joystickKnob.style.transform = 'translate(-50%, -50%)';
            touchControls.moveX = 0;
            touchControls.moveY = 0;
        }

        // Touch shooting on canvas
        canvas.addEventListener('touchstart', handleCanvasTouch, { passive: false });

        function handleCanvasTouch(e) {
            e.preventDefault();
            if (!game.running) return;

            // Get the first touch (joystick touches won't reach here due to stopPropagation)
            const touch = e.touches[0];
            
            // Check if touch is on ability buttons (bottom-right)
            const isOnAbilityButtons = (
                touch.clientX >= window.innerWidth - 100 &&
                touch.clientY >= window.innerHeight - 250
            );
            
            // If not on ability buttons, shoot!
            if (!isOnAbilityButtons) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const targetX = (touch.clientX - rect.left) * scaleX;
                const targetY = (touch.clientY - rect.top) * scaleY;

                // Update aim point to where we tapped
                game.mouseX = targetX;
                game.mouseY = targetY;

                // Calculate staff position based on tap location
                const dx = targetX - game.player.x;
                const dy = targetY - game.player.y;
                const angle = Math.atan2(dy, dx);
                const staffX = game.player.x + Math.cos(angle) * 35;
                const staffY = game.player.y + Math.sin(angle) * 35;

                // Shoot from staff toward tap point
                const shootDx = targetX - staffX;
                const shootDy = targetY - staffY;
                const shootDist = Math.sqrt(shootDx * shootDx + shootDy * shootDy);

                game.projectiles.push({
                    x: staffX, y: staffY,
                    vx: (shootDx / shootDist) * 6,
                    vy: (shootDy / shootDist) * 6,
                    size: 6
                });

                createParticles(staffX, staffY, game.waveColor, 5);
            }
        }

        // Touch move on canvas removed - aiming only happens on tap
        // This prevents the staff from following your finger while using joystick

        // Initialize
        document.getElementById('startBtn').disabled = true;
        
        window.addEventListener('load', () => {
            document.getElementById('playerNameInput').focus();
        });
    </script>
</body>

</html>
